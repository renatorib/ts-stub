import fs from "fs";
import path from "path";
import pc from "picocolors";
import { extractExportsIdentifiers } from "./exports.js";

export type Entry = string | { input?: string; output?: string; format?: string; noEmit?: boolean };

const ENTRY_DEFAULTS = {
  input: "src/index.ts",
  output: "dist",
  format: "esm:mjs",
  noEmit: false,
};

export async function stub({
  entry,
  cwd = process.cwd(),
  quiet,
  clear,
  noEffects,
}: {
  entry?: Entry | Entry[];
  cwd?: string;
  quiet?: boolean;
  clear?: boolean;
  noEffects?: boolean;
}) {
  const entries = Array.isArray(entry) ? entry : [entry];
  const result = await Promise.all(
    entries.map(async (entry) => {
      const normalizedEntry =
        entry == null
          ? ENTRY_DEFAULTS
          : typeof entry === "string"
            ? { ...ENTRY_DEFAULTS, input: entry }
            : { ...ENTRY_DEFAULTS, ...filterUndefinedValues(entry) };

      const { input, output, noEmit, format: _format } = normalizedEntry;

      const [format, rawExt = format == "esm" ? "mjs" : "cjs"] = _format.split(":");
      const ext = rawExt.startsWith(".") ? rawExt : `.${rawExt}`;

      if (path.extname(output) !== "") {
        throw new TypeError("[ts-stub] entry output must be a directory");
      }

      if (!/(?<!\.d)(\.(m|c)?tsx?)$/.test(path.basename(input))) {
        throw new TypeError("[ts-stub] entry input must be a typescript source file");
      }

      if (!["esm", "cjs"].includes(format)) {
        throw new TypeError(
          `[ts-stub] Format "${format}" not supported. Please use one of: "esm", "cjs"`,
        );
      }

      const allowedExts = {
        esm: [".js", ".mjs"],
        cjs: [".js", ".cjs"],
      }[format as "esm" | "cjs"];

      if (!allowedExts.includes(ext)) {
        throw new TypeError(
          `[ts-stub] Extension "${ext}" not supported for "${format}". Please use one of: ${allowedExts
            .map((ext) => `"${ext}"`)
            .join(", ")}`,
        );
      }

      const outputFile = path.join(
        path.join(cwd, output),
        path.basename(input, path.extname(input)) + ext,
      );

      const identifiers = extractExportsIdentifiers(new URL("file://" + path.join(cwd, input)));

      const files = new Map<string, string>();

      if (format === "esm") {
        const esm = ["// This file was auto-generated by ts-stub"];
        if (identifiers.size > 0) {
          const destructured = [...identifiers].map(([name, meta]) =>
            meta.default && !meta.named ? `default: ${name}` : name,
          );
          const exportsSpecifiers = [...identifiers]
            .flatMap(([name, meta]) => [meta.default && `${name} as default`, meta.named && name])
            .filter(Boolean);

          esm.push(
            `import { require } from "tsx/cjs/api";`,
            `const { ${destructured.join(", ")} } = require("../${input}", import.meta.url);`,
            `export { ${exportsSpecifiers.join(", ")} };`,
          );
        }

        files.set(outputFile, esm.join("\n"));
      }

      if (format === "cjs") {
        const cjs = [
          "// This file was auto-generated by ts-stub",
          `const tsx = require("tsx/cjs/api");`,
          `module.exports = require("../${input}", __dirnmame);`,
        ];

        files.set(outputFile, cjs.join("\n"));
      }

      if (!noEmit) {
        const hasNamed = [...identifiers.values()].some((m) => m.named);
        const hasDefault = [...identifiers.values()].some((m) => m.default);

        const dts = [
          "// This file was auto-generated by ts-stub",
          hasNamed && `export * from "../${input}";`,
          hasDefault && `export { default } from "../${input}";`,
        ].filter(Boolean);

        files.set(outputFile.slice(0, -path.extname(outputFile).length) + ".d.ts", dts.join("\n"));
      }

      return files;
    }),
  );

  const files = new Map(result.flatMap((files) => [...files.entries()]));
  const uniqueDirs = [...new Set([...files.keys()].map(path.dirname))];

  if (!noEffects) {
    if (clear) {
      await Promise.all(
        uniqueDirs.map((dir) =>
          fs.promises.rm(dir, { force: true, recursive: true }).then(() => {
            if (!quiet) {
              console.log(pc.green("✓"), pc.dim("Cleaned"), pc.gray(truncateEnd(dir, 30, "…/")));
            }
          }),
        ),
      );
      await Promise.all(uniqueDirs.map((dir) => fs.promises.mkdir(dir, { recursive: true })));
    }

    await Promise.all(
      [...files].map(([file, content]) =>
        fs.promises.writeFile(file, content, "utf8").then(() => {
          if (!quiet) {
            console.log(pc.green("✓"), pc.blue("Stubbed"), pc.gray(truncateEnd(file, 30, "…")));
          }
        }),
      ),
    );
  }

  return files;
}

function truncateEnd(str: string, size: number, prefix: string = "") {
  if (str.length < size - prefix.length) return str;
  return prefix + str.slice(-(size - prefix.length));
}

function filterUndefinedValues(obj: object) {
  return Object.fromEntries(Object.entries(obj).filter((entry) => entry[1] !== undefined));
}
